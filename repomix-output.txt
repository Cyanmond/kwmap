This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
static/
  main.js
  style.css
templates/
  index.html
.gitignore
app.py
init_db.py
LICENSE
repomix-output.txt
requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="static/style.css">
html, body {
    margin: 0;
    padding: 0;
    height: 100%;
}

#map {
    width: 100%;
    height: 100%
}
</file>

<file path="repomix-output.txt">
This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
app.py
init_db.py
LICENSE
requirements.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="LICENSE">
MIT License

Copyright (c) 2025 Isane Sekiguchi

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="requirements.txt">
blinker==1.9.0
click==8.1.8
Flask==3.1.0
importlib_metadata==8.6.1
itsdangerous==2.2.0
Jinja2==3.1.6
MarkupSafe==3.0.2
Werkzeug==3.1.3
zipp==3.21.0
</file>

<file path="app.py">
from flask import Flask, jsonify, render_template
import sqlite3, json

app = Flask(__name__)

# Returns all features in the main_map table as a GeoJSON FeatureCollection
@app.route("/api/main_map")
def get_main_map():
    # connect to db
    conn = sqlite3.connect("database.db")
    conn.row_factory = sqlite3.Row

    # extract all records from main_map table
    rows = conn.execute("SELECT * FROM main_map;").fetchall()
    conn.close()

    features = []
    for row in rows:
        # str -> dict conversion
        geometry = json.loads(row["geometry"])

        properties = {
            "id": row["id"],
            "name" : row["name"],
            "type": row["type"],
            "desc": row["desc"]
        }
        features.append({
            "type": "Feature",
            "properties": properties,
            "geometry": geometry
        })
    
    return jsonify({
        "type": "FeatureCollection",
        "features": features
    })

# Returns all buildings as a GeoJSON FeatureCollection
@app.route("/api/buildings")
def get_buildings():
    # connect to db
    conn = sqlite3.connect("database.db")
    conn.row_factory = sqlite3.Row

    # extract all records from buildings table
    rows = conn.execute("SELECT * FROM buildings;").fetchall()
    conn.close()

    features = []
    for row in rows:
        # str -> dict conversion
        geometry = json.loads(row["geometry"])

        properties = {
            "building_id": row["building_id"],
            "name": row["name"],
            "desc": row["desc"]
        }
        features.append({
            "type": "Feature",
            "properties": properties,
            "geometry": geometry
        })
    
    return jsonify({
        "type": "FeatureCollection",
        "features": features
    })

# Returns all floors in the given building
@app.route("/api/buildings/<building_id>/floors")
def get_floors(building_id):
    # connect to db
    conn = sqlite3.connect("database.db")
    conn.row_factory = sqlite3.Row

    # extract all records from buildings table with the given building_id
    """
    SQL Statement:

    SELECT * FROM floors
    WHERE building_id = {building_id};
    """
    rows = conn.execute("SELECT * FROM floors"
                        "WHERE building_id = ?;", (building_id, )).fetchall()
    conn.close()

    features = []
    for row in rows:
        # str -> dict conversion
        geometry = json.loads(row["geometry"])

        properties = {
            "floor_id": row["id"],
            "building_id": row["building_id"],
            "name": row["name"],
            "sort_order": row["sort_order"],
            "desc": row["desc"]
        }
        features.append({
            "type": "Feature",
            "properties": properties,
            "geometry": geometry
        })

    return jsonify({
        "type": "FeatureCollection",
        "features": features
    })

@app.route("/api/buildings/<building_id>/floors/<floor_id>/locations")
def get_locations(building_id, floor_id):
    # connect to db
    conn = sqlite3.connect("database.db")
    conn.row_factory = sqlite3.Row

    # extract all records from buildings table with the given building_id
    """
    SQL Statement:

    SELECT * FROM floors
    WHERE floor_id = {floor_id};
    """
    rows = conn.execute("SELECT * FROM locations"
                        "WHERE floor_id = ?;", (floor_id, )).fetchall()
    conn.close()

    features = []
    for row in rows:
        # str -> dict conversion
        geometry = json.loads(row["geometry"])

        properties = {
            "location_id": row["location_id"],
            "floor_id": row["floor_id"],
            "name": row["name"],
            "type": row["type"],
            "desc": row["desc"]
        }
        features.append({
            "type": "Feature",
            "properties": properties,
            "geometry": geometry
        })

    return jsonify({
        "type": "FeatureCollection",
        "features": features
    })


@app.route("/")
def home():
    return render_template("index.html")

if __name__ == "__main__":
    app.run(debug=True)
</file>

<file path="init_db.py">
import json, sqlite3

def create_main_map():
    conn = sqlite3.connect("database.db")

    # main_map
    conn.execute("DROP TABLE IF EXISTS main_map;")
    conn.execute("CREATE TABLE main_map ("
    "id INTEGER PRIMARY KEY,"
    "name TEXT,"
    "type TEXT,"
    "desc TEXT,"
    "geometry TEXT"
    ");")
    with open("./data/map/main_map.geojson", "r") as json_file:
        count = 0
        data = json.load(json_file)["features"]
        for item in data:
            rdata = item["properties"] # dict object
            # extract data to be stored in db
            did = count
            dname = rdata["name"]
            dtype = rdata["type"]
            ddesc = rdata["desc"]
            dgeometry = item["geometry"]

            # insert a record
            conn.execute("INSERT INTO main_map (id, name, type, desc, geometry)"
                         "VALUES (?, ?, ?, ?, ?)", 
                         (did, dname, dtype, ddesc, json.dumps(dgeometry))
            )
            count += 1

    conn.commit()
    conn.close()

def create_buildings():
    conn = sqlite3.connect("database.db")

    # buildings
    conn.execute("DROP TABLE IF EXISTS buildings;")
    conn.execute(
        "CREATE TABLE buildings ("
        "building_id TEXT PRIMARY KEY, "
        "name TEXT, "
        "desc TEXT, "
        "geometry TEXT)"
    )

    with open("./data/map/buildings.geojson", "r") as json_file:
        data = json.load(json_file)["features"]
        for item in data:
            rdata = item["properties"] # dict object
            # extract data to be stored in db
            did  = rdata["building_id"]
            dname = rdata["name"]
            ddesc = rdata["desc"]
            dgeometry = json.dumps(item["geometry"])

            # insert a record
            conn.execute(
                "INSERT INTO buildings (building_id, name, desc, geometry) "
                "VALUES (?, ?, ?, ?)",
                (did, dname, ddesc, dgeometry)
            )

    conn.commit()
    conn.close()

def create_floors():
    conn = sqlite3.connect("database.db")
    conn.execute("PRAGMA foreign_keys = ON;") # enforce fk

    conn.execute("DROP TABLE IF EXISTS floors;")
    conn.execute(
        "CREATE TABLE floors ("
        "floor_id TEXT PRIMARY KEY, "
        "building_id TEXT, "
        "name TEXT, "
        "sort_order INTEGER, "
        "desc TEXT, "
        "geometry TEXT, "
        "FOREIGN KEY (building_id) REFERENCES buildings(building_id)"
        ")"
    )

    with open("./data/map/floors.geojson", "r") as json_file:
        data = json.load(json_file)["features"]
        for item in data:
            rdata = item["properties"] # dict object
            #extract data to be stored in db
            dfloor_id = rdata["floor_id"]
            dbuilding_id = rdata["building_id"]
            dname = rdata["name"]
            dsort_order = rdata["sort_order"]
            ddesc = rdata["desc"]
            dgeometry = json.dumps(item["geometry"])

            #insert a record
            conn.execute(
                "INSERT INTO floors (floor_id, building_id, name, sort_order, desc, geometry)"
                "VALUES(?, ?, ?, ?, ?, ?)",
                (dfloor_id, dbuilding_id, dname, dsort_order, ddesc, dgeometry)
            )

    conn.commit()
    conn.close()

def create_locations():
    conn = sqlite3.connect("database.db")
    conn.execute("PRAGMA foreign_keys = ON;")  # Enforce FK constraints

    conn.execute("DROP TABLE IF EXISTS locations;")
    conn.execute(
        "CREATE TABLE locations ("
        "location_id TEXT PRIMARY KEY, "
        "floor_id TEXT, "
        "name TEXT, "
        "type TEXT, "
        "desc TEXT, "
        "geometry TEXT, "
        "FOREIGN KEY (floor_id) REFERENCES floors(floor_id))"
    )

    with open("./data/map/locations.geojson", "r") as json_file:
        data = json.load(json_file)["features"]
        for item in data:
            rdata = item["properties"] # dict object
            # extract data to be stored in db
            dlocation_id = rdata["location_id"]
            dfloor_id = rdata["floor_id"]
            dname = rdata["name"]
            dtype = rdata["type"]
            ddesc = rdata["desc"]
            dgeometry = json.dumps(item["geometry"])
            conn.execute(
                "INSERT INTO locations (location_id, floor_id, name, type, desc, geometry) "
                "VALUES(?, ?, ?, ?, ?, ?)",
                (dlocation_id, dfloor_id, dname, dtype, ddesc, dgeometry)
            )

    conn.commit()
    conn.close()

def main():
    create_main_map()
    create_buildings()
    create_floors()
    create_locations()

if __name__ == "__main__":
    main()
</file>

<file path=".gitignore">
# Python cache files
__pycache__/
*.pyc

# Virtual environment
venv/

# SQLite database (local only)
*.db

# raw data
data/

# system files
.DS_Store
Thumbs.db

#repomix
repomix-output.xml

# test
zzz.*
</file>

</files>
</file>

<file path="static/main.js">
class MapApp {
    constructor(elementId, options) {
      this.map = L.map(elementId).setView(options.center, options.zoom);
  
      L.tileLayer(
        options.tileUrl,
        {
          attribution: options.tileAttribution
        }
      ).addTo(this.map);
    }
  }
  
  document.addEventListener('DOMContentLoaded', () => {
    const app = new MapApp('map', {
      center: [51.505, -0.09],  // Default view: London
      zoom: 13,
      tileUrl: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      tileAttribution: '&copy; <a href="https://openstreetmap.org">OpenStreetMap</a> contributors'
    });
  });
</file>

<file path="templates/index.html">
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>KWMap</title>

        <!-- leaflet css -->
        <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
        <!-- my project's css -->
        <link rel="stylesheet" href="../static/style.css">
    </head>

    <body>
        <div id="map"></div>

        <!-- leaflet script -->
        <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
        <!-- my project's js -->
        <script src="{{ url_for('static', filename='main.js') }}"></script>
    </body>
</html>
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2025 Isane Sekiguchi

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="requirements.txt">
blinker==1.9.0
click==8.1.8
Flask==3.1.0
importlib_metadata==8.6.1
itsdangerous==2.2.0
Jinja2==3.1.6
MarkupSafe==3.0.2
Werkzeug==3.1.3
zipp==3.21.0
</file>

<file path="app.py">
from flask import Flask, jsonify, render_template
import sqlite3, json

app = Flask(__name__)

# Returns all features in the main_map table as a GeoJSON FeatureCollection
@app.route("/api/main_map")
def get_main_map():
    # connect to db
    conn = sqlite3.connect("database.db")
    conn.row_factory = sqlite3.Row

    # extract all records from main_map table
    rows = conn.execute("SELECT * FROM main_map;").fetchall()
    conn.close()

    features = []
    for row in rows:
        # str -> dict conversion
        geometry = json.loads(row["geometry"])

        properties = {
            "id": row["id"],
            "name" : row["name"],
            "type": row["type"],
            "desc": row["desc"]
        }
        features.append({
            "type": "Feature",
            "properties": properties,
            "geometry": geometry
        })
    
    return jsonify({
        "type": "FeatureCollection",
        "features": features
    })

# Returns all buildings as a GeoJSON FeatureCollection
@app.route("/api/buildings")
def get_buildings():
    # connect to db
    conn = sqlite3.connect("database.db")
    conn.row_factory = sqlite3.Row

    # extract all records from buildings table
    rows = conn.execute("SELECT * FROM buildings;").fetchall()
    conn.close()

    features = []
    for row in rows:
        # str -> dict conversion
        geometry = json.loads(row["geometry"])

        properties = {
            "building_id": row["building_id"],
            "name": row["name"],
            "desc": row["desc"]
        }
        features.append({
            "type": "Feature",
            "properties": properties,
            "geometry": geometry
        })
    
    return jsonify({
        "type": "FeatureCollection",
        "features": features
    })

# Returns all floors in the given building
@app.route("/api/buildings/<building_id>/floors")
def get_floors(building_id):
    # connect to db
    conn = sqlite3.connect("database.db")
    conn.row_factory = sqlite3.Row

    # extract all records from buildings table with the given building_id
    """
    SQL Statement:

    SELECT * FROM floors
    WHERE building_id = {building_id};
    """
    rows = conn.execute("SELECT * FROM floors"
                        "WHERE building_id = ?;", (building_id, )).fetchall()
    conn.close()

    features = []
    for row in rows:
        # str -> dict conversion
        geometry = json.loads(row["geometry"])

        properties = {
            "floor_id": row["id"],
            "building_id": row["building_id"],
            "name": row["name"],
            "sort_order": row["sort_order"],
            "desc": row["desc"]
        }
        features.append({
            "type": "Feature",
            "properties": properties,
            "geometry": geometry
        })

    return jsonify({
        "type": "FeatureCollection",
        "features": features
    })

@app.route("/api/buildings/<building_id>/floors/<floor_id>/locations")
def get_locations(building_id, floor_id):
    # connect to db
    conn = sqlite3.connect("database.db")
    conn.row_factory = sqlite3.Row

    # extract all records from buildings table with the given building_id
    """
    SQL Statement:

    SELECT * FROM floors
    WHERE floor_id = {floor_id};
    """
    rows = conn.execute("SELECT * FROM locations"
                        "WHERE floor_id = ?;", (floor_id, )).fetchall()
    conn.close()

    features = []
    for row in rows:
        # str -> dict conversion
        geometry = json.loads(row["geometry"])

        properties = {
            "location_id": row["location_id"],
            "floor_id": row["floor_id"],
            "name": row["name"],
            "type": row["type"],
            "desc": row["desc"]
        }
        features.append({
            "type": "Feature",
            "properties": properties,
            "geometry": geometry
        })

    return jsonify({
        "type": "FeatureCollection",
        "features": features
    })


@app.route("/")
def home():
    return render_template("index.html")

if __name__ == "__main__":
    app.run(debug=True)
</file>

<file path="init_db.py">
import json, sqlite3

def create_main_map():
    conn = sqlite3.connect("database.db")

    # main_map
    conn.execute("DROP TABLE IF EXISTS main_map;")
    conn.execute("CREATE TABLE main_map ("
    "id INTEGER PRIMARY KEY,"
    "name TEXT,"
    "type TEXT,"
    "desc TEXT,"
    "geometry TEXT"
    ");")
    with open("./data/map/main_map.geojson", "r") as json_file:
        count = 0
        data = json.load(json_file)["features"]
        for item in data:
            rdata = item["properties"] # dict object
            # extract data to be stored in db
            did = count
            dname = rdata["name"]
            dtype = rdata["type"]
            ddesc = rdata["desc"]
            dgeometry = item["geometry"]

            # insert a record
            conn.execute("INSERT INTO main_map (id, name, type, desc, geometry)"
                         "VALUES (?, ?, ?, ?, ?)", 
                         (did, dname, dtype, ddesc, json.dumps(dgeometry))
            )
            count += 1

    conn.commit()
    conn.close()

def create_buildings():
    conn = sqlite3.connect("database.db")

    # buildings
    conn.execute("DROP TABLE IF EXISTS buildings;")
    conn.execute(
        "CREATE TABLE buildings ("
        "building_id TEXT PRIMARY KEY, "
        "name TEXT, "
        "desc TEXT, "
        "geometry TEXT)"
    )

    with open("./data/map/buildings.geojson", "r") as json_file:
        data = json.load(json_file)["features"]
        for item in data:
            rdata = item["properties"] # dict object
            # extract data to be stored in db
            did  = rdata["building_id"]
            dname = rdata["name"]
            ddesc = rdata["desc"]
            dgeometry = json.dumps(item["geometry"])

            # insert a record
            conn.execute(
                "INSERT INTO buildings (building_id, name, desc, geometry) "
                "VALUES (?, ?, ?, ?)",
                (did, dname, ddesc, dgeometry)
            )

    conn.commit()
    conn.close()

def create_floors():
    conn = sqlite3.connect("database.db")
    conn.execute("PRAGMA foreign_keys = ON;") # enforce fk

    conn.execute("DROP TABLE IF EXISTS floors;")
    conn.execute(
        "CREATE TABLE floors ("
        "floor_id TEXT PRIMARY KEY, "
        "building_id TEXT, "
        "name TEXT, "
        "sort_order INTEGER, "
        "desc TEXT, "
        "geometry TEXT, "
        "FOREIGN KEY (building_id) REFERENCES buildings(building_id)"
        ")"
    )

    with open("./data/map/floors.geojson", "r") as json_file:
        data = json.load(json_file)["features"]
        for item in data:
            rdata = item["properties"] # dict object
            #extract data to be stored in db
            dfloor_id = rdata["floor_id"]
            dbuilding_id = rdata["building_id"]
            dname = rdata["name"]
            dsort_order = rdata["sort_order"]
            ddesc = rdata["desc"]
            dgeometry = json.dumps(item["geometry"])

            #insert a record
            conn.execute(
                "INSERT INTO floors (floor_id, building_id, name, sort_order, desc, geometry)"
                "VALUES(?, ?, ?, ?, ?, ?)",
                (dfloor_id, dbuilding_id, dname, dsort_order, ddesc, dgeometry)
            )

    conn.commit()
    conn.close()

def create_locations():
    conn = sqlite3.connect("database.db")
    conn.execute("PRAGMA foreign_keys = ON;")  # Enforce FK constraints

    conn.execute("DROP TABLE IF EXISTS locations;")
    conn.execute(
        "CREATE TABLE locations ("
        "location_id TEXT PRIMARY KEY, "
        "floor_id TEXT, "
        "name TEXT, "
        "type TEXT, "
        "desc TEXT, "
        "geometry TEXT, "
        "FOREIGN KEY (floor_id) REFERENCES floors(floor_id))"
    )

    with open("./data/map/locations.geojson", "r") as json_file:
        data = json.load(json_file)["features"]
        for item in data:
            rdata = item["properties"] # dict object
            # extract data to be stored in db
            dlocation_id = rdata["location_id"]
            dfloor_id = rdata["floor_id"]
            dname = rdata["name"]
            dtype = rdata["type"]
            ddesc = rdata["desc"]
            dgeometry = json.dumps(item["geometry"])
            conn.execute(
                "INSERT INTO locations (location_id, floor_id, name, type, desc, geometry) "
                "VALUES(?, ?, ?, ?, ?, ?)",
                (dlocation_id, dfloor_id, dname, dtype, ddesc, dgeometry)
            )

    conn.commit()
    conn.close()

def main():
    create_main_map()
    create_buildings()
    create_floors()
    create_locations()

if __name__ == "__main__":
    main()
</file>

<file path=".gitignore">
# Python cache files
__pycache__/
*.pyc

# Virtual environment
venv/

# SQLite database (local only)
*.db

# raw data
data/

# system files
.DS_Store
Thumbs.db

#repomix
repomix-output.xml

# test
zzz.*
</file>

</files>
